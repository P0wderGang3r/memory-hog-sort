# Бесполезный метод сортировки
В общем, бесполезный ввиду затрат по памяти и времени метод сортировки.

## Идея
Отсортировать все элементы входящего массива по десяткам процентов на своеобразном промежутке от минимума до максимума.

## Общая сводка по времени
    1000000 элементов в пределах от 0 до 1000000. 

    Memory hog. Time estimated: 1044479368 нс.

    Bubble. Time estimated: 182547309 нс.

    Quick. Time estimated: 132670404 нс.

## Как работает
1. Поиск минимума и максимума в исходном массиве.
3. Создание массива массивов из 11 массивов, логически представленных следующим образом:


    Представление:
    min ->  0% | 10% | 20% | 30% | 40% | 50% | 60% | 70% | 80% | 90% | 100%  <- max

3. Проходим по оригинальному массиву элементов с определением местоположения следующим образом:


    Целая часть числа при вычислении ((curr_elem - min) / (max - min)) * 10:
    min ->  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  10  <- max

4. Определив местоположение, отправляем элемент на полученное место в матрицу. Проходим в цикле 3 шаг, пока ещё есть элементы. В результате мы имеем подобную матрицу при случайных 24 элементах:



    min ->  0% | 10% | 20% | 30% | 40% | 50% | 60% | 70% | 80% | 90% | 100% <- max

    Пусть min = 0, max = 100 для простоты 
    min ->  6  | 19  | 24  |  -  | 44  | 53  | 66  | 72  | 80  | 91  | 100  <- max
    min ->  4  | 17  | 28  |  -  | 47  |  -  | 66  | 70  | 88  | 99  | 100  <- max
    min ->  8  | 12  |  -  |  -  | 41  |  -  | 66  |  -  |  -  | 95  |  -   <- max

6. Если входящий массив содержит все одинаковые числа, то есть не получилось разбить подмассив на множество разных подмассивов, то добавляем все элементы этого массива в конец актуального массива элементов и переходим к шагу 9. 
7. Далее каждый из подмассивов, если он содержит более одного элемента, кидаем в шаг 1.
8. Если массив содержит один элемент, кидаем его в конец актуального массива.
9. Производим возврат содержимого актуального массива.