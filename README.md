# Бесполезный метод сортировки
В общем, неэффективный ввиду затрат по памяти и относительно неэффективный по времени метод сортировки. Ввиду сложности подхода будет в разы проще написать QuickSort.

## Идея
Отсортировать все элементы входящего массива по десяткам процентов на своеобразном промежутке от минимума до максимума.

## Общая сводка по времени
```
10000 элементов в пределах от 0 до 10000.

Memory hog. Time estimated: 22458642 нс.

Bubble. Time estimated: 790129761 нс.

Quick. Time estimated: 7823449 нс.
```
## Как работает
1. Поиск минимума и максимума в исходном массиве.
3. Создание массива массивов из 11 массивов, логически представленных следующим образом:
```
Представление:
min ->  0% | 10% | 20% | 30% | 40% | 50% | 60% | 70% | 80% | 90% | 100%  <- max
```
3. Проходим по оригинальному массиву элементов с определением местоположения следующим образом:
```
Целая часть числа при вычислении ((curr_elem - min) / (max - min)) * 10:
min ->  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  10  <- max
```
4. Определив местоположение, отправляем элемент на полученное место в матрицу. Проходим в цикле 3 шаг, пока ещё есть элементы. В результате мы имеем подобную матрицу при случайных 24 элементах:
```
min ->  0% | 10% | 20% | 30% | 40% | 50% | 60% | 70% | 80% | 90% | 100% <- max

Пусть min = 0, max = 100 для простоты 
min ->  6  | 19  | 24  |  -  | 44  | 53  | 66  | 72  | 80  | 91  | 100  <- max
min ->  4  | 17  | 28  |  -  | 47  |  -  | 66  | 70  | 88  | 99  | 100  <- max
min ->  8  | 12  |  -  |  -  | 41  |  -  | 66  |  -  |  -  | 95  |  -   <- max
```
6. Если входящий массив содержит все одинаковые числа, то есть не получилось разбить подмассив на множество разных подмассивов, то добавляем все элементы этого массива в конец актуального массива элементов и переходим к шагу 9.
7. Далее каждый из подмассивов, если он содержит более одного элемента, кидаем в шаг 1.
8. Если массив содержит один элемент, кидаем его в конец актуального массива.
9. Производим возврат содержимого актуального массива.

## А что в итоге?
Идеи, приходящие в час ночи, могут быть столь же амбициозными, сколь и бесполезными. Мне было интересно :) Надеюсь, что и вам тоже. Удачи!

## Дополнительная информация
В файле Globals.java вы можете изменить значение переменной show_process на 2, чтобы получить более подробный отчёт о происходящем "под капотом". Помните, что в таком случае все полученные измерения времени перестают быть корректными ввиду дополнительных затрат времени на вывод на экран. 